<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="I/O,Linux,PageCache," />










<meta name="description" content="本文转载自 http://www.v2ex.com/t/278921   原作者微博 ID ： orroz  http://weibo.com/orroz   微信公众号： Linux 系统技术  在 Linux 系统中，我们经常用 free 命令来查看系统内存的使用状态。在一个 RHEL6 的系统上， free 命令的显示内容大概是这样一个状态：">
<meta name="keywords" content="I&#x2F;O,Linux,PageCache">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内存中的 Cache 真的能被回收么？">
<meta property="og:url" content="http://lidawn.github.io/2016/06/02//linux-cache//index.html">
<meta property="og:site_name" content="大栗子菜市场">
<meta property="og:description" content="本文转载自 http://www.v2ex.com/t/278921   原作者微博 ID ： orroz  http://weibo.com/orroz   微信公众号： Linux 系统技术  在 Linux 系统中，我们经常用 free 命令来查看系统内存的使用状态。在一个 RHEL6 的系统上， free 命令的显示内容大概是这样一个状态：">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-06T03:28:26.779Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux 内存中的 Cache 真的能被回收么？">
<meta name="twitter:description" content="本文转载自 http://www.v2ex.com/t/278921   原作者微博 ID ： orroz  http://weibo.com/orroz   微信公众号： Linux 系统技术  在 Linux 系统中，我们经常用 free 命令来查看系统内存的使用状态。在一个 RHEL6 的系统上， free 命令的显示内容大概是这样一个状态：">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lidawn.github.io/2016/06/02//linux-cache//"/>





  <title>Linux 内存中的 Cache 真的能被回收么？ | 大栗子菜市场</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大栗子菜市场</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lidawn.github.io/2016/06/02/linux-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大栗子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大栗子菜市场">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux 内存中的 Cache 真的能被回收么？</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-02T00:00:00+08:00">
                2016-06-02
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/06/02/linux-cache/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2016/06/02/linux-cache/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/06/02/linux-cache/" class="leancloud_visitors" data-flag-title="Linux 内存中的 Cache 真的能被回收么？">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文转载自 <a href="http://www.v2ex.com/t/278921" target="_blank" rel="noopener">http://www.v2ex.com/t/278921</a></p>
</blockquote>
<blockquote>
<p>原作者微博 ID ： orroz  <a href="http://weibo.com/orroz" target="_blank" rel="noopener">http://weibo.com/orroz</a></p>
</blockquote>
<blockquote>
<p>微信公众号： Linux 系统技术</p>
</blockquote>
<p>在 Linux 系统中，我们经常用 free 命令来查看系统内存的使用状态。在一个 RHEL6 的系统上， free 命令的显示内容大概是这样一个状态：</p>
<a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@tencent64 ~]<span class="comment"># free</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:     132256952   72571772   59685180          0    1762632   53034704</span><br><span class="line">-/+ buffers/cache:   17774436  114482516</span><br><span class="line">Swap:      2101192        508    2100684</span><br></pre></td></tr></table></figure>
<p>这里的默认显示单位是 kb ，我的服务器是 128G 内存，所以数字显得比较大。这个命令几乎是每一个使用过 Linux 的人必会的命令，但越是这样的命令，似乎真正明白的人越少（我是说比例越少）。一般情况下，对此命令输出的理解可以分这几个层次：</p>
<p>不了解。这样的人的第一反应是：天啊，内存用了好多， 70 个多 G ，可是我几乎没有运行什么大程序啊？为什么会这样？ Linux 好占内存！<br>自以为很了解。这样的人一般自习评估过会说：嗯，根据我专业的眼光看出来，内存才用了 17G 左右，还有很多剩余内存可用。 buffers/cache 占用的较多，说明系统中有进程曾经读写过文件，但是不要紧，这部分内存是当空闲来用的。<br>真的很了解。这种人的反应反而让人感觉最不懂 Linux ，他们的反应是： free 显示的是这样，好吧我知道了。神马？你问我这些内存够不够，我当然不知道啦！我特么怎么知道你程序怎么写的？<br>根据目前网络上技术文档的内容，我相信绝大多数了解一点 Linux 的人应该处在第二种层次。大家普遍认为， buffers 和 cached 所占用的内存空间是可以在内存压力较大的时候被释放当做空闲空间用的。但真的是这样么？在论证这个题目之前，我们先简要介绍一下 buffers 和 cached 是什么意思：</p>
<h2 id="什么是-buffer-cache-？"><a href="#什么是-buffer-cache-？" class="headerlink" title="什么是 buffer/cache ？"></a>什么是 buffer/cache ？</h2><p>buffer 和 cache 是两个在计算机技术中被用滥的名词，放在不通语境下会有不同的意义。在 Linux 的内存管理中，这里的 buffer 指 Linux 内存的： Buffer cache 。这里的 cache 指 Linux 内存中的： Page cache 。翻译成中文可以叫做缓冲区缓存和页面缓存。在历史上，它们一个（ buffer ）被用来当成对 io 设备写的缓存，而另一个（ cache ）被用来当作对 io 设备的读缓存，这里的 io 设备，主要指的是块设备文件和文件系统上的普通文件。但是现在，它们的意义已经不一样了。在当前的内核中， page cache 顾名思义就是针对内存页的缓存，说白了就是，如果有内存是以 page 进行分配管理的，都可以使用 page cache 作为其缓存来管理使用。当然，不是所有的内存都是以页（ page ）进行管理的，也有很多是针对块（ block ）进行管理的，这部分内存使用如果要用到 cache 功能，则都集中到 buffer cache 中来使用。（从这个角度出发，是不是 buffer cache 改名叫做 block cache 更好？）然而，也不是所有块（ block ）都有固定长度，系统上块的长度主要是根据所使用的块设备决定的，而页长度在 X86 上无论是 32 位还是 64 位都是 4k 。</p>
<p>明白了这两套缓存系统的区别，就可以理解它们究竟都可以用来做什么了。</p>
<p><strong>什么是 page cache</strong></p>
<p>Page cache 主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有 read ／ write 操作的时候。如果你仔细想想的话，作为可以映射文件到内存的系统调用： mmap 是不是很自然的也应该用到 page cache ？在当前的系统实现里， page cache 也被作为其它文件类型的缓存设备来用，所以事实上 page cache 也负责了大部分的块设备文件的缓存工作。</p>
<p><strong>什么是 buffer cache</strong></p>
<p>Buffer cache 则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。这意味着某些对块的操作会使用 buffer cache 进行缓存，比如我们在格式化文件系统的时候。一般情况下两个缓存系统是一起配合使用的，比如当我们对一个文件进行写操作的时候， page cache 的内容会被改变，而 buffer cache 则可以用来将 page 标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。这样，内核在后续执行脏数据的回写（ writeback ）时，就不用将整个 page 写回，而只需要写回修改的部分即可。</p>
<h2 id="如何回收-cache-？"><a href="#如何回收-cache-？" class="headerlink" title="如何回收 cache ？"></a>如何回收 cache ？</h2><p>Linux 内核会在内存将要耗尽的时候，触发内存回收的工作，以便释放出内存给急需内存的进程使用。一般情况下，这个操作中主要的内存释放都来自于对 buffer ／ cache 的释放。尤其是被使用更多的 cache 空间。既然它主要用来做缓存，只是在内存够用的时候加快进程对文件的读写速度，那么在内存压力较大的情况下，当然有必要清空释放 cache ，作为 free 空间分给相关进程使用。所以一般情况下，我们认为 buffer/cache 空间可以被释放，这个理解是正确的。</p>
<p>但是这种清缓存的工作也并不是没有成本。理解 cache 是干什么的就可以明白清缓存必须保证 cache 中的数据跟对应文件中的数据一致，才能对 cache 进行释放。所以伴随着 cache 清除的行为的，一般都是系统 IO 飙高。因为内核要对比 cache 中的数据和对应硬盘文件上的数据是否一致，如果不一致需要写回，之后才能回收。</p>
<p>在系统中除了内存将被耗尽的时候可以清缓存以外，我们还可以使用下面这个文件来人工触发缓存清除的操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@tencent64 ~]<span class="comment"># cat /proc/sys/vm/drop_caches </span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>方法是：</p>
<p><code>echo 1 &gt; /proc/sys/vm/drop_caches</code><br>当然，这个文件可以设置的值分别为 1 、 2 、 3 。它们所表示的含义为：    <code>echo 1 &gt; /proc/sys/vm/drop_caches</code>:表示清除 pagecache 。</p>
<p><code>echo 2 &gt; /proc/sys/vm/drop_caches</code>:表示清除回收 slab 分配器中的对象（包括目录项缓存和 inode 缓存）。 slab 分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的 pagecache 。</p>
<p><code>echo 3 &gt; /proc/sys/vm/drop_caches</code>:表示清除 pagecache 和 slab 分配器中的缓存对象。</p>
<h2 id="cache-都能被回收么？"><a href="#cache-都能被回收么？" class="headerlink" title="cache 都能被回收么？"></a>cache 都能被回收么？</h2><p>我们分析了 cache 能被回收的情况，那么有没有不能被回收的 cache 呢？当然有。我们先来看第一种情况：</p>
<h3 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a>tmpfs</h3><p>大家知道 Linux 提供一种“临时”文件系统叫做 tmpfs ，它可以将内存的一部分空间拿来当做文件系统使用，使内存空间可以当做目录文件来用。现在绝大多数 Linux 系统都有一个叫做 /dev/shm 的 tmpfs 目录，就是这样一种存在。当然，我们也可以手工创建一个自己的 tmpfs ，方法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@tencent64 ~]<span class="comment"># mkdir /tmp/tmpfs</span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># mount -t tmpfs -o size=20G none /tmp/tmpfs/</span></span><br><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># df</span></span><br><span class="line">Filesystem           1K-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/sda1             10325000   3529604   6270916  37% /</span><br><span class="line">/dev/sda3             20646064   9595940  10001360  49% /usr/<span class="built_in">local</span></span><br><span class="line">/dev/mapper/vg-data  103212320  26244284  71725156  27% /data</span><br><span class="line">tmpfs                 66128476  14709004  51419472  23% /dev/shm</span><br><span class="line">none                  20971520         0  20971520   0% /tmp/tmpfs</span><br></pre></td></tr></table></figure>
<p>于是我们就创建了一个新的 tmpfs ，空间是 20G ，我们可以在 /tmp/tmpfs 中创建一个 20G 以内的文件。如果我们创建的文件实际占用的空间是内存的话，那么这些数据应该占用内存空间的什么部分呢？根据 pagecache 的实现功能可以理解，既然是某种文件系统，那么自然该使用 pagecache 的空间来管理。我们试试是不是这样？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         36         89          0          1         19</span><br><span class="line">-/+ buffers/cache:         15        111</span><br><span class="line">Swap:            2          0          2</span><br><span class="line">[root@tencent64 ~]<span class="comment"># dd if=/dev/zero of=/tmp/tmpfs/testfile bs=1G count=13</span></span><br><span class="line">13+0 records <span class="keyword">in</span></span><br><span class="line">13+0 records out</span><br><span class="line">13958643712 bytes (14 GB) copied, 9.49858 s, 1.5 GB/s</span><br><span class="line">[root@tencent64 ~]<span class="comment"># </span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         49         76          0          1         32</span><br><span class="line">-/+ buffers/cache:         15        110</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>我们在 tmpfs 目录下创建了一个 13G 的文件，并通过前后 free 命令的对比发现， cached 增长了 13G ，说明这个文件确实放在了内存里并且内核使用的是 cache 作为存储。再看看我们关心的指标：    -/+ buffers/cache 那一行。我们发现，在这种情况下 free 命令仍然提示我们有 110G 内存可用，但是真的有这么多么？我们可以人工触发内存回收看看现在到底能回收多少内存：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tencent64 ~]<span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         43         82          0          0         29</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>可以看到， cached 占用的空间并没有像我们想象的那样完全被释放，其中 13G 的空间仍然被 /tmp/tmpfs 中的文件占用的。当然，我的系统中还有其他不可释放的 cache 占用着其余 16G 内存空间。那么 tmpfs 占用的 cache 空间什么时候会被释放呢？是在其文件被删除的时候.如果不删除文件，无论内存耗尽到什么程度，内核都不会自动帮你把 tmpfs 中的文件删除来释放 cache 空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@tencent64 ~]<span class="comment"># rm /tmp/tmpfs/testfile </span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         30         95          0          0         16</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>这是我们分析的第一种 cache 不能被回收的情况。还有其他情况，比如：</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存是系统提供给我们的一种常用的进程间通信（ IPC ）方式，但是这种通信方式不能在 shell 中申请和使用，所以我们需要一个简单的测试程序，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="meta"># cat shm.c </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMSIZE 2048*1024*1023</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    shmid = shmget(IPC_PRIVATE, MEMSIZE, <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (shmid&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"shmget()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = shmctl(shmid, IPC_STAT, &amp;buf);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"shmctl()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shmid: %d\n"</span>, shmid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shmsize: %d\n"</span>, buf.shm_segsz);</span><br><span class="line"></span><br><span class="line">    buf.shm_segsz *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    ret = shmctl(shmid, IPC_SET, &amp;buf);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"shmctl()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = shmctl(shmid, IPC_SET, &amp;buf);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"shmctl()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shmid: %d\n"</span>, shmid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"shmsize: %d\n"</span>, buf.shm_segsz);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid==<span class="number">0</span>) &#123;</span><br><span class="line">        ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ptr==(<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"shmat()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        bzero(ptr, MEMSIZE);</span><br><span class="line">        <span class="built_in">strcpy</span>(ptr, <span class="string">"Hello!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ptr==(<span class="keyword">void</span>*)<span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">"shmat()"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(ptr);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序功能很简单，就是申请一段不到 2G 共享内存，然后打开一个子进程对这段共享内存做一个初始化操作，父进程等子进程初始化完之后输出一下共享内存的内容，然后退出。但是退出之前并没有删除这段共享内存。我们来看看这个程序执行前后的内存使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         30         95          0          0         16</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br><span class="line">[root@tencent64 ~]<span class="comment"># ./shm </span></span><br><span class="line">shmid: 294918</span><br><span class="line">shmsize: 2145386496</span><br><span class="line">shmid: 294918</span><br><span class="line">shmsize: -4194304</span><br><span class="line">Hello!</span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         32         93          0          0         18</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>cached 空间由 16G 涨到了 18G 。那么这段 cache 能被回收么？继续测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         32         93          0          0         18</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>结果是仍然不可回收。大家可以观察到，这段共享内存即使没人使用，仍然会长期存放在 cache 中，直到其被删除。删除方法有两种，一种是程序中使用 shmctl()去 IPC_RMID ，另一种是使用 ipcrm 命令。我们来删除试试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># ipcs -m</span></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      4                       </span><br><span class="line">0x00005fe7 32769      root       666        524288     2                       </span><br><span class="line">0x00005fe8 65538      root       666        2097152    2                       </span><br><span class="line">0x00038c0e 131075     root       777        2072       1                       </span><br><span class="line">0x00038c14 163844     root       777        5603392    0                       </span><br><span class="line">0x00038c09 196613     root       777        221248     0                       </span><br><span class="line">0x00000000 294918     root       600        2145386496 0                       </span><br><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># ipcrm -m 294918</span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># ipcs -m</span></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0x00005feb 0          root       666        12000      4                       </span><br><span class="line">0x00005fe7 32769      root       666        524288     2                       </span><br><span class="line">0x00005fe8 65538      root       666        2097152    2                       </span><br><span class="line">0x00038c0e 131075     root       777        2072       1                       </span><br><span class="line">0x00038c14 163844     root       777        5603392    0                       </span><br><span class="line">0x00038c09 196613     root       777        221248     0                       </span><br><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         30         95          0          0         16</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>删除共享内存后， cache 被正常释放了。这个行为与 tmpfs 的逻辑类似。内核底层在实现共享内存（ shm ）、消息队列（ msg ）和信号量数组（ sem ）这些 POSIX:XSI 的 IPC 机制的内存存储时，使用的都是 tmpfs 。这也是为什么共享内存的操作逻辑与 tmpfs 类似的原因。当然，一般情况下是 shm 占用的内存更多，所以我们在此重点强调共享内存的使用。说到共享内存， Linux 还给我们提供了另外一种共享内存的方法，就是：</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p>mmap()是一个非常重要的系统调用，这仅从 mmap 本身的功能描述上是看不出来的。从字面上看， mmap 就是将一个文件映射进进程的虚拟内存地址，之后就可以通过操作内存的方式对文件的内容进行操作。但是实际上这个调用的用途是很广泛的。当 malloc 申请内存时，小段内存内核使用 sbrk 处理，而大段内存就会使用 mmap 。当系统调用 exec 族函数执行时，因为其本质上是将一个可执行文件加载到内存执行，所以内核很自然的就可以使用 mmap 方式进行处理。我们在此仅仅考虑一种情况，就是使用 mmap 进行共享内存的申请时，会不会跟 shmget()一样也使用 cache ？</p>
<p>同样，我们也需要一个简单的测试程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="meta"># cat mmap.c </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMSIZE 1024*1024*1023*2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MPFILE <span class="meta-string">"./mmapfile"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">	fd = open(MPFILE, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"open()"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ptr = mmap(<span class="literal">NULL</span>, MEMSIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">"malloc()"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p\n"</span>, ptr);</span><br><span class="line">	bzero(ptr, MEMSIZE);</span><br><span class="line"></span><br><span class="line">	sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	munmap(ptr, MEMSIZE);</span><br><span class="line">	close(fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次我们干脆不用什么父子进程的方式了，就一个进程，申请一段 2G 的 mmap 共享内存，然后初始化这段空间之后等待 100 秒，再解除影射所以我们需要在它 sleep 这 100 秒内检查我们的系统内存使用，看看它用的是什么空间？当然在这之前要先创建一个 2G 的文件./mmapfile 。结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># dd if=/dev/zero of=mmapfile bs=1G count=2</span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         30         95          0          0         16</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>然后执行测试程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># ./mmap &amp;</span></span><br><span class="line">[1] 19157</span><br><span class="line">0x7f1ae3635000</span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         32         93          0          0         18</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># echo 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         32         93          0          0         18</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在程序执行期间， cached 一直为 18G ，比之前涨了 2G ，并且此时这段 cache 仍然无法被回收。然后我们等待 100 秒之后程序结束。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@tencent64 ~]<span class="comment"># </span></span><br><span class="line">[1]+  Exit 1                  ./mmap</span><br><span class="line">[root@tencent64 ~]<span class="comment"># </span></span><br><span class="line">[root@tencent64 ~]<span class="comment"># free -g</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:           126         30         95          0          0         16</span><br><span class="line">-/+ buffers/cache:         14        111</span><br><span class="line">Swap:            2          0          2</span><br></pre></td></tr></table></figure>
<p>程序退出之后， cached 占用的空间被释放。这样我们可以看到，使用 mmap 申请标志状态为 MAP_SHARED 的内存，内核也是使用的 cache 进行存储的。在进程对相关内存没有释放之前，这段 cache 也是不能被正常释放的。实际上， mmap 的 MAP_SHARED 方式申请的内存，在内核中也是由 tmpfs 实现的。由此我们也可以推测，由于共享库的只读部分在内存中都是以 mmap 的 MAP_SHARED 方式进行管理，实际上它们也都是要占用 cache 且无法被释放的。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们通过三个测试例子，发现 Linux 系统内存中的 cache 并不是在所有情况下都能被释放当做空闲空间用的。并且也也明确了，即使可以释放 cache ，也并不是对系统来说没有成本的。总结一下要点，我们应该记得这样几点：</p>
<p>当 cache 作为文件缓存被释放的时候会引发 IO 变高，这是 cache 加快文件访问速度所要付出的成本。<br>tmpfs 中存储的文件会占用 cache 空间，除非文件删除否则这个 cache 不会被自动释放。<br>使用 shmget 方式申请的共享内存会占用 cache 空间，除非共享内存被 ipcrm 或者使用 shmctl 去 IPC_RMID ，否则相关的 cache 空间都不会被自动释放。<br>使用 mmap 方法申请的 MAP_SHARED 标志的内存会占用 cache 空间，除非进程将这段内存 munmap ，否则相关的 cache 空间都不会被自动释放。<br>实际上 shmget 、 mmap 的共享内存，在内核层都是通过 tmpfs 实现的， tmpfs 实现的存储用的都是 cache 。<br>当理解了这些的时候，希望大家对 free 命令的理解可以达到我们说的第三个层次。我们应该明白，内存的使用并不是简单的概念， cache 也并不是真的可以当成空闲空间用的。如果我们要真正深刻理解你的系统上的内存到底使用的是否合理，是需要理解清楚很多更细节知识，并且对相关业务的实现做更细节判断的。我们当前实验场景是 Centos 6 的环境，不同版本的 Linux 的 free 现实的状态可能不一样，大家可以自己去找出不同的原因。</p>
<p>当然，本文所述的也不是所有的 cache 不能被释放的情形。那么，在你的应用场景下，还有那些 cache 不能被释放的场景呢？</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/I-O/" rel="tag"># I/O</a>
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
            <a href="/tags/PageCache/" rel="tag"># PageCache</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/01/datastructure-algorithm/" rel="next" title="基本数据结构与算法">
                <i class="fa fa-chevron-left"></i> 基本数据结构与算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/02/pdf-outline-table/" rel="prev" title="维护地球和平之 - 利用 Python 从PDF中提取目录和表格">
                维护地球和平之 - 利用 Python 从PDF中提取目录和表格 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大栗子</p>
              <p class="site-description motion-element" itemprop="description">IT,Life,逗比.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是-buffer-cache-？"><span class="nav-number">1.</span> <span class="nav-text">什么是 buffer/cache ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何回收-cache-？"><span class="nav-number">2.</span> <span class="nav-text">如何回收 cache ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cache-都能被回收么？"><span class="nav-number">3.</span> <span class="nav-text">cache 都能被回收么？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tmpfs"><span class="nav-number">3.1.</span> <span class="nav-text">tmpfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享内存"><span class="nav-number">3.2.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap"><span class="nav-number">3.3.</span> <span class="nav-text">mmap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最后"><span class="nav-number">4.</span> <span class="nav-text">最后</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大栗子</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'ko6l8xFspD4CbRWPXXQ59oKH-gzGzoHsz',
        appKey: 'mn4p5kSMuj83sTfEmFPEYL4d',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'20' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ko6l8xFspD4CbRWPXXQ59oKH-gzGzoHsz", "mn4p5kSMuj83sTfEmFPEYL4d");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
